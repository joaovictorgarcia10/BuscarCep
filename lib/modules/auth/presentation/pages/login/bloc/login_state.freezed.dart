// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'login_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$DoLoginStateTearOff {
  const _$DoLoginStateTearOff();

  _$DoLoginStateEmpty empty() {
    return const _$DoLoginStateEmpty();
  }

  _$DoLoginStateLoading loading() {
    return const _$DoLoginStateLoading();
  }

  _$DoLoginStateFailure failure({required Failure failure}) {
    return _$DoLoginStateFailure(
      failure: failure,
    );
  }

  _$DoLoginStateSuccess success({required User user}) {
    return _$DoLoginStateSuccess(
      user: user,
    );
  }
}

/// @nodoc
const $DoLoginState = _$DoLoginStateTearOff();

/// @nodoc
mixin _$DoLoginState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function(Failure failure) failure,
    required TResult Function(User user) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$DoLoginStateEmpty value) empty,
    required TResult Function(_$DoLoginStateLoading value) loading,
    required TResult Function(_$DoLoginStateFailure value) failure,
    required TResult Function(_$DoLoginStateSuccess value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoLoginStateCopyWith<$Res> {
  factory $DoLoginStateCopyWith(
          DoLoginState value, $Res Function(DoLoginState) then) =
      _$DoLoginStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$DoLoginStateCopyWithImpl<$Res> implements $DoLoginStateCopyWith<$Res> {
  _$DoLoginStateCopyWithImpl(this._value, this._then);

  final DoLoginState _value;
  // ignore: unused_field
  final $Res Function(DoLoginState) _then;
}

/// @nodoc
abstract class _$$DoLoginStateEmptyCopyWith<$Res> {
  factory _$$DoLoginStateEmptyCopyWith(
          _$DoLoginStateEmpty value, $Res Function(_$DoLoginStateEmpty) then) =
      __$$DoLoginStateEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DoLoginStateEmptyCopyWithImpl<$Res>
    extends _$DoLoginStateCopyWithImpl<$Res>
    implements _$$DoLoginStateEmptyCopyWith<$Res> {
  __$$DoLoginStateEmptyCopyWithImpl(
      _$DoLoginStateEmpty _value, $Res Function(_$DoLoginStateEmpty) _then)
      : super(_value, (v) => _then(v as _$DoLoginStateEmpty));

  @override
  _$DoLoginStateEmpty get _value => super._value as _$DoLoginStateEmpty;
}

/// @nodoc

class _$_$DoLoginStateEmpty implements _$DoLoginStateEmpty {
  const _$_$DoLoginStateEmpty();

  @override
  String toString() {
    return 'DoLoginState.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DoLoginStateEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function(Failure failure) failure,
    required TResult Function(User user) success,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$DoLoginStateEmpty value) empty,
    required TResult Function(_$DoLoginStateLoading value) loading,
    required TResult Function(_$DoLoginStateFailure value) failure,
    required TResult Function(_$DoLoginStateSuccess value) success,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _$DoLoginStateEmpty implements DoLoginState {
  const factory _$DoLoginStateEmpty() = _$_$DoLoginStateEmpty;
}

/// @nodoc
abstract class _$$DoLoginStateLoadingCopyWith<$Res> {
  factory _$$DoLoginStateLoadingCopyWith(_$DoLoginStateLoading value,
          $Res Function(_$DoLoginStateLoading) then) =
      __$$DoLoginStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DoLoginStateLoadingCopyWithImpl<$Res>
    extends _$DoLoginStateCopyWithImpl<$Res>
    implements _$$DoLoginStateLoadingCopyWith<$Res> {
  __$$DoLoginStateLoadingCopyWithImpl(
      _$DoLoginStateLoading _value, $Res Function(_$DoLoginStateLoading) _then)
      : super(_value, (v) => _then(v as _$DoLoginStateLoading));

  @override
  _$DoLoginStateLoading get _value => super._value as _$DoLoginStateLoading;
}

/// @nodoc

class _$_$DoLoginStateLoading implements _$DoLoginStateLoading {
  const _$_$DoLoginStateLoading();

  @override
  String toString() {
    return 'DoLoginState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DoLoginStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function(Failure failure) failure,
    required TResult Function(User user) success,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$DoLoginStateEmpty value) empty,
    required TResult Function(_$DoLoginStateLoading value) loading,
    required TResult Function(_$DoLoginStateFailure value) failure,
    required TResult Function(_$DoLoginStateSuccess value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _$DoLoginStateLoading implements DoLoginState {
  const factory _$DoLoginStateLoading() = _$_$DoLoginStateLoading;
}

/// @nodoc
abstract class _$$DoLoginStateFailureCopyWith<$Res> {
  factory _$$DoLoginStateFailureCopyWith(_$DoLoginStateFailure value,
          $Res Function(_$DoLoginStateFailure) then) =
      __$$DoLoginStateFailureCopyWithImpl<$Res>;
  $Res call({Failure failure});
}

/// @nodoc
class __$$DoLoginStateFailureCopyWithImpl<$Res>
    extends _$DoLoginStateCopyWithImpl<$Res>
    implements _$$DoLoginStateFailureCopyWith<$Res> {
  __$$DoLoginStateFailureCopyWithImpl(
      _$DoLoginStateFailure _value, $Res Function(_$DoLoginStateFailure) _then)
      : super(_value, (v) => _then(v as _$DoLoginStateFailure));

  @override
  _$DoLoginStateFailure get _value => super._value as _$DoLoginStateFailure;

  @override
  $Res call({
    Object? failure = freezed,
  }) {
    return _then(_$DoLoginStateFailure(
      failure: failure == freezed
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as Failure,
    ));
  }
}

/// @nodoc

class _$_$DoLoginStateFailure implements _$DoLoginStateFailure {
  const _$_$DoLoginStateFailure({required this.failure});

  @override
  final Failure failure;

  @override
  String toString() {
    return 'DoLoginState.failure(failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DoLoginStateFailure &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  _$$DoLoginStateFailureCopyWith<_$DoLoginStateFailure> get copyWith =>
      __$$DoLoginStateFailureCopyWithImpl<_$DoLoginStateFailure>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function(Failure failure) failure,
    required TResult Function(User user) success,
  }) {
    return failure(this.failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
  }) {
    return failure?.call(this.failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this.failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$DoLoginStateEmpty value) empty,
    required TResult Function(_$DoLoginStateLoading value) loading,
    required TResult Function(_$DoLoginStateFailure value) failure,
    required TResult Function(_$DoLoginStateSuccess value) success,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class _$DoLoginStateFailure implements DoLoginState {
  const factory _$DoLoginStateFailure({required Failure failure}) =
      _$_$DoLoginStateFailure;

  Failure get failure;
  @JsonKey(ignore: true)
  _$$DoLoginStateFailureCopyWith<_$DoLoginStateFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DoLoginStateSuccessCopyWith<$Res> {
  factory _$$DoLoginStateSuccessCopyWith(_$DoLoginStateSuccess value,
          $Res Function(_$DoLoginStateSuccess) then) =
      __$$DoLoginStateSuccessCopyWithImpl<$Res>;
  $Res call({User user});
}

/// @nodoc
class __$$DoLoginStateSuccessCopyWithImpl<$Res>
    extends _$DoLoginStateCopyWithImpl<$Res>
    implements _$$DoLoginStateSuccessCopyWith<$Res> {
  __$$DoLoginStateSuccessCopyWithImpl(
      _$DoLoginStateSuccess _value, $Res Function(_$DoLoginStateSuccess) _then)
      : super(_value, (v) => _then(v as _$DoLoginStateSuccess));

  @override
  _$DoLoginStateSuccess get _value => super._value as _$DoLoginStateSuccess;

  @override
  $Res call({
    Object? user = freezed,
  }) {
    return _then(_$DoLoginStateSuccess(
      user: user == freezed
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
    ));
  }
}

/// @nodoc

class _$_$DoLoginStateSuccess implements _$DoLoginStateSuccess {
  const _$_$DoLoginStateSuccess({required this.user});

  @override
  final User user;

  @override
  String toString() {
    return 'DoLoginState.success(user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DoLoginStateSuccess &&
            const DeepCollectionEquality().equals(other.user, user));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(user));

  @JsonKey(ignore: true)
  @override
  _$$DoLoginStateSuccessCopyWith<_$DoLoginStateSuccess> get copyWith =>
      __$$DoLoginStateSuccessCopyWithImpl<_$DoLoginStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() loading,
    required TResult Function(Failure failure) failure,
    required TResult Function(User user) success,
  }) {
    return success(user);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
  }) {
    return success?.call(user);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? loading,
    TResult Function(Failure failure)? failure,
    TResult Function(User user)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(user);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_$DoLoginStateEmpty value) empty,
    required TResult Function(_$DoLoginStateLoading value) loading,
    required TResult Function(_$DoLoginStateFailure value) failure,
    required TResult Function(_$DoLoginStateSuccess value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_$DoLoginStateEmpty value)? empty,
    TResult Function(_$DoLoginStateLoading value)? loading,
    TResult Function(_$DoLoginStateFailure value)? failure,
    TResult Function(_$DoLoginStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _$DoLoginStateSuccess implements DoLoginState {
  const factory _$DoLoginStateSuccess({required User user}) =
      _$_$DoLoginStateSuccess;

  User get user;
  @JsonKey(ignore: true)
  _$$DoLoginStateSuccessCopyWith<_$DoLoginStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}
